# TypeScript Standards for T3 Stack

## Strict TypeScript Rules

### Type Safety Requirements
- **NEVER use `any` type** - always provide proper type definitions
- Use `unknown` instead of `any` when type is truly unknown
- Leverage TypeScript's strict mode configuration
- Use proper type guards and narrowing techniques

### Type Definitions
- Define interfaces for all data structures
- Use type aliases for complex union types
- Prefer interfaces over type aliases for object shapes
- Use generic types for reusable components and functions

### Zod Integration
- Use Zod schemas for runtime validation
- Define schemas that match TypeScript interfaces
- Use `z.infer<typeof schema>` to derive types from Zod schemas
- Validate all external data with Zod before use

### Next.js App Router Types
- Use proper types for Server Components vs Client Components
- Leverage Next.js built-in types for routing and metadata
- Use proper types for Server Actions with next-safe-action
- Type all props and return values explicitly

### Database Types
- Use Prisma's generated types for database entities
- Create proper DTOs (Data Transfer Objects) for API responses
- Type all database queries and mutations
- Use proper error types for database operations

### Environment Variables
- Use the `@t3-oss/env-nextjs` package for type-safe env vars
- Define all environment variables in [src/env.js](mdc:src/env.js)
- Never access `process.env` directly
- Use the exported `env` object for all environment access

### Component Props
- Always type component props with interfaces
- Use proper React types for event handlers
- Leverage TypeScript's utility types for prop manipulation
- Use proper types for children and render props

### API and Server Actions
- Type all Server Action parameters and return values
- Use proper error types for API responses
- Type all form data and validation schemas
- Use proper types for authentication and user data

### Best Practices
- Use `const assertions` for immutable data
- Leverage `satisfies` operator for type checking
- Use proper generic constraints
- Implement proper error handling with typed errors
- Use TypeScript's built-in utility types effectively
description:
globs:
alwaysApply: false
---
